<?xml version="1.0" encoding="ISO-8859-1"?><xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  xmlns:SMLNL="http://www.shef.ac.uk/SpineMLNetworkLayer" xmlns:SMLCL="http://www.shef.ac.uk/SpineMLComponentLayer" xmlns:fn="http://www.w3.org/2005/xpath-functions">
<xsl:output method="text" version="1.0" encoding="UTF-8" indent="yes"/>

<xsl:param name="spineml_2_brahms_dir" select="'../../'"/>

<xsl:include href="SpineML_helpers.xsl"/>


<xsl:template match="/">
<xsl:for-each select="//SMLNL:Synapse">
<xsl:variable name="process_name"><xsl:value-of select="local-name(SMLNL:ConnectionList)"/><xsl:value-of select="local-name(SMLNL:FixedProbabilityConnection)"/><xsl:value-of select="local-name(SMLNL:AllToAllConnection)"/><xsl:value-of select="local-name(SMLNL:OneToOneConnection)"/><xsl:value-of select="translate(document(SMLNL:WeightUpdate/@url)//SMLCL:ComponentClass/@name,' -', 'oH')"/></xsl:variable>
<!--xsl:variable name="rule_proto" select="@prototype"/>
<xsl:variable name="rule_file" select="document(/SMLNL:SpineML/SMLNL:Node[@name=$rule_proto]/@url)"/-->
<xsl:variable name="WeightUpdate_file" select="document(SMLNL:WeightUpdate/@url)"/>
<!-- Here we use the numbers to determine what we are outputting -->
<xsl:variable name="number1"><xsl:number count="//SMLNL:Population" format="1"/></xsl:variable>
<xsl:variable name="number2"><xsl:number count="//SMLNL:Projection" format="1"/></xsl:variable>
<xsl:variable name="number3"><xsl:number count="//SMLNL:Synapse" format="1"/></xsl:variable>
<xsl:if test="$number1 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number1) and $number2 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number2) and $number3 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number3)">

<xsl:variable name="dstPopName" select="../../@dst_population"/>
<xsl:variable name="dstPop" select="//SMLNL:Population[SMLNL:Neuron/@name=$dstPopName]"/>

/*
   Autogenerated BRAHMS process from SpineML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: <xsl:value-of select="$process_name"/>
*/

#define COMPONENT_CLASS_STRING "dev/SpineML/temp/<xsl:value-of select="$process_name"/>"
#define COMPONENT_CLASS_CPP dev_nineml_<xsl:value-of select="$process_name"/>_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=SpineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "rng.h"

#include "impulse.h"

/* helper function for doing the indexing... do we need this?
int getIndex(VDOUBLE position, VDOUBLE size) {

	int index = 0;
	int mult = 1;
	for (int i = 0; i &lt; size.size(); ++i) {
		index = index + pos[i] * mult;
		mult = mult * size[i];
	}

}*/

// structure allowing weights to be sent with spikes
struct INT32SINGLE {
	INT32 i;
	SINGLE s;
};

float dt;
float t;

class COMPONENT_CLASS_CPP;

<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncsPtr1"/>
</xsl:for-each>



////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:



// define regimes
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineRegime"/>
</xsl:for-each>


// Global variables
vector &lt; int &gt; <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime;
vector &lt; int &gt; <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext;


VDOUBLE size;
int numConn;
int numElements;
int numElementsIn;

VUINT32 delayForConn;

vector &lt; VINT32 &gt; delayBuffer;
vector &lt; VDOUBLE &gt; delayedImpulseVals;

int delayBufferIndex;

// create the lookups for the connectivity
vector &lt; vector &lt; int &gt; &gt; connectivityS2C;
vector &lt; vector &lt; int &gt; &gt; connectivityD2C;
vector &lt; int &gt; connectivityC2S;
vector &lt; int &gt; connectivityC2D;

// Analog Ports
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogSendPort | SMLCL:AnalogReducePort" mode="defineAnalogPorts"/>
</xsl:for-each>

// Event Ports
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="defineEventPorts"/>
</xsl:for-each>

// Impulse Ports
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="defineImpulsePorts"/>
</xsl:for-each>

// State Variables
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:StateVariable" mode="defineStateVariable"/>
</xsl:for-each>

// Parameters
<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:Parameter" mode="defineParameter"/>
</xsl:for-each>

<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncs"/>
</xsl:for-each>

float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	return x + (*this.*func)(x,num)*dt;

}
/*
// Runge Kutta 4th order
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	float k1 = dt*(*this.*func)(x,num);
	float k2 = dt*(*this.*func)(x+0.5*k1,num);
	float k3 = dt*(*this.*func)(x+0.5*k2,num);
	float k4 = dt*(*this.*func)(x+k3,num);
	return x + (1.0/6.0)*(k1 + 2.0*k2 + 2.0*k3 + k4);

}
*/
};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
		
			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&amp;xmlNode);

			// obtain the parameters
			size = nodeState.getField("sizeIn").getArrayDOUBLE();
			numElementsIn = 1;
			for (int i = 0; i &lt; size.size(); ++i) {
				numElementsIn *= size[i];
			}		

			size = nodeState.getField("sizeOut").getArrayDOUBLE();
			numElements = 1;
			for (int i = 0; i &lt; size.size(); ++i) {
				numElements *= size[i];
			}	

			zigset(11);

			// Create the connectivity map
                        <xsl:if test="count(./SMLNL:AllToAllConnection) = 1">
			connectivityC2D.reserve(numElementsIn*numElements);
			connectivityS2C.resize(numElementsIn);
			for (UINT32 i = 0; i &lt; connectivityS2C.size(); ++i) {
				connectivityS2C[i].resize(numElements);
				for (uint j = 0; j &lt; connectivityS2C[i].size(); ++j) {
					connectivityC2D.push_back(j);
					connectivityS2C[i][j] = connectivityC2D.size()-1;
					
				} 
			}
			
			// set up the number of connections
			numConn = connectivityC2D.size();
			</xsl:if>
                        <xsl:if test="count(./SMLNL:OneToOneConnection) = 1">
			connectivityC2D.resize(numElementsIn);
			connectivityS2C.resize(numElementsIn);
			for (UINT32 i = 0; i &lt; connectivityS2C.size(); ++i) {
				connectivityS2C[i].push_back(i); 
			}
			for (UINT32 i = 0; i &lt; connectivityC2D.size(); ++i) {
				connectivityC2D[i] = i; 
			}
			
			// set up the number of connections
			numConn = connectivityC2D.size();			
			</xsl:if>
			
            <xsl:if test="count(./SMLNL:FixedProbabilityConnection) = 1">
			// get the probability
			float probabilityValue = nodeState.getField("probabilityValue").getDOUBLE();
			// seed the rng:
            zigset(1<xsl:value-of select=".//SMLNL:FixedProbabilityConnection/@seed"/>);
            seed = 123;
			// run through connections, creating connectivity pattern:			
			connectivityC2D.reserve(numElements);
			connectivityS2C.resize(numElementsIn);
			for (UINT32 i = 0; i &lt; connectivityS2C.size(); ++i) {
				connectivityS2C[i].reserve((int) round(numElements*probabilityValue));
			}			
			for (UINT32 srcIndex = 0; srcIndex &lt; numElementsIn; ++srcIndex) {
				for (UINT32 dstIndex = 0; dstIndex &lt; numElements; ++dstIndex) {
					if (UNI &lt; probabilityValue) {
					connectivityC2D.push_back(dstIndex);
					connectivityS2C[srcIndex].push_back(connectivityC2D.size()-1);
					}
					
				}
				if (float(connectivityC2D.size()) > 0.9*float(connectivityC2D.capacity()))	
					connectivityC2D.reserve(connectivityC2D.capacity()+numElements);		
			}
			
			// set up the number of connections
			numConn = connectivityC2D.size();
			//bout &lt;&lt; float(numConn) &lt;&lt; D_INFO;
			</xsl:if>
                        <xsl:if test="count(./SMLNL:ConnectionList) = 1">
			vector &lt;INT32&gt; srcInds; 
			srcInds = nodeState.getField("src").getArrayINT32();

			vector &lt;INT32&gt; dstInds; 
			dstInds = nodeState.getField("dst").getArrayINT32();

			if (srcInds.size() != dstInds.size()) 
				berr &lt;&lt; "Connectivity src and dst lists have different sizes";

			numConn = srcInds.size();
			
			// sanity check on index values
			for (uint i = 0; i &lt; srcInds.size(); ++i) {
				if (srcInds[i] >= numElementsIn || dstInds[i] >= numElements)
					berr &lt;&lt; "index out of range";
			} 
			
			// assign the connectivity pattern into memory
			connectivityS2C.resize(numElementsIn);
			connectivityC2D.resize(srcInds.size());
			for (int i = 0; i &lt; srcInds.size(); ++i) {
				connectivityS2C[srcInds[i]].push_back(i);
				connectivityC2D[i] = dstInds[i];			
			}
			</xsl:if>
			
			// get delay
			if (nodeState.hasField("delayForConn")) {
			
				VDOUBLE delayForConnTemp = nodeState.getField("delayForConn").getArrayDOUBLE();

				if (delayForConnTemp.size() != numConn) berr &lt;&lt; "Connectivity delay list has incorrect size";
				
				delayBufferIndex = 0;
				
				// resize buffer
				float max_delay_val = 0;
				float most_delay_accuracy = (1000.0f * time->sampleRate.den / time->sampleRate.num)*10;
				for (UINT32 i = 0; i &lt; delayForConnTemp.size(); ++i) {
					delayForConnTemp[i];
					if (delayForConnTemp[i] > max_delay_val) max_delay_val = delayForConnTemp[i];					
				}
				
				delayBuffer.resize(round(max_delay_val*most_delay_accuracy)+1);
				delayedImpulseVals.resize(round(max_delay_val*most_delay_accuracy)+1);
				
				// remap the delays to indices
				delayForConn.resize(delayForConnTemp.size());
				
				//delayBufferIndexCounter = 0;
				//delayBufferIndexCounterMax = round(most_delay_accuracy/(1000.0f * time->sampleRate.den / time->sampleRate.num));
				
				bout&lt;&lt; most_delay_accuracy &lt;&lt; D_INFO;
				bout&lt;&lt; float(delayBuffer.size()) &lt;&lt; D_INFO;
				for (UINT32 i = 0; i &lt; delayForConnTemp.size(); ++i) {
					delayForConn[i] = round(delayForConnTemp[i]*most_delay_accuracy);
					//&lt;&lt;delayForConn[i] &lt;&lt; D_INFO;
				}
				
				
			
			}

//debug
//bout &lt;&lt; float(numConn) &lt;&lt; D_INFO;

			int numEl = numConn;

			// State Variables
<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
				<xsl:apply-templates select="SMLCL:StateVariable" mode="assignStateVariable"/>
			</xsl:for-each>

			

			// Parameters
<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Parameter" mode="assignParameter"/>
			</xsl:for-each>

			// Alias resize
<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
				<xsl:apply-templates select="SMLCL:Alias" mode="resizeAlias"/>
			</xsl:for-each>

<xsl:text>
                        </xsl:text><xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.resize(numConn,1);
                        <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext.resize(numConn,0);


			dt = 1000.0f * time->sampleRate.den / time->sampleRate.num;

<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
				<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncsPtr"/>
			</xsl:for-each>
<!---->

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort" mode="resizeReceive"/>
			</xsl:for-each>
		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
			Dims sizeDims;
			for (int i = 0; i &lt; size.size(); ++i) {
				sizeDims.push_back(size[i]);
			}
			//	on first call
			if (event->flags &amp; F_FIRST_CALL)
			{

				// create output ports
<!---->
				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogSendPort" mode="createAnalogSendPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:ImpulseSendPort" mode="createImpulseSendPortsWU"/>
				</xsl:for-each>

				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:EventSendPort" mode="createEventSendPorts"/>
				</xsl:for-each>
<!---->

			}

			//	on last call
			if (event->flags &amp; F_LAST_CALL)
			{

				int numInputs;
				Symbol set;

				// create input ports
<!---->
				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogReceivePort" mode="createAnalogRecvPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogReducePort" mode="createAnalogReducePorts"/>
				</xsl:for-each>

				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:ImpulseReceivePort" mode="createImpulseRecvPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:EventReceivePort" mode="createEventRecvPorts"/>
				</xsl:for-each>

<!---->

			}

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{
			t = float(time->now)*dt;
			
			int num;
			int numEl = numConn;
			
			// move delayBufferIndex
			if (delayBuffer.size()) {
				++delayBufferIndex;
				delayBufferIndex = delayBufferIndex%delayBuffer.size();
			}
			
                        for (int i = 0; i &lt; <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.size(); ++i) {
                                <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext[i] = <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime[i];

			}
			
			// service inputs
<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogReducePort" mode="serviceAnalogPortsRemap"/>
			</xsl:for-each>
			
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="serviceImpulsePortsRemap"/>
			</xsl:for-each>

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="serviceEventPortsRemap"/>
			</xsl:for-each>		

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doEventInputsRemap"/>
			</xsl:for-each>
			
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doImpulseInputsRemap"/>
			</xsl:for-each>

			<!-- REMAPPED -->

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doIter"/>
			</xsl:for-each>

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doTrans"/>
			</xsl:for-each>
<!---->

			// Apply regime changes
                        for (int i = 0; i &lt; <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.size(); ++i) {
                                <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime[i] = <xsl:value-of select="concat(translate($WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext[i];
			}

<!---->
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogSendPort | SMLCL:AnalogReducePort" mode="outputAnalogPortsRemap"/>
			</xsl:for-each>

			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="outputEventPortsRemap"/>
			</xsl:for-each>	
			
			<xsl:for-each select="$WeightUpdate_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="outputImpulsePortsRemap"/>
			</xsl:for-each>	

		//bout &lt;&lt; " " &lt;&lt; OUTPSP[2] &lt;&lt; " " &lt;&lt; out[0] &lt;&lt; " " &lt;&lt; w[0] &lt;&lt; D_INFO;		

			
			//	ok
			return C_OK;
		}

	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


</xsl:if>


</xsl:for-each>


</xsl:template>

<xsl:include href="SpineML_Dynamics.xsl"/>
<xsl:include href="SpineML_Regime.xsl"/>
<xsl:include href="SpineML_StateVariable.xsl"/>
<xsl:include href="SpineML_Parameter.xsl"/>
<xsl:include href="SpineML_AnalogPort.xsl"/>
<xsl:include href="SpineML_EventPort.xsl"/>
<xsl:include href="SpineML_ImpulsePort.xsl"/>

</xsl:stylesheet>


