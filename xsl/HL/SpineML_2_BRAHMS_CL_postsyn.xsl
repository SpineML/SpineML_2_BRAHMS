<?xml version="1.0" encoding="ISO-8859-1"?><xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  xmlns:SMLNL="http://www.shef.ac.uk/SpineMLNetworkLayer" xmlns:SMLCL="http://www.shef.ac.uk/SpineMLComponentLayer" xmlns:fn="http://www.w3.org/2005/xpath-functions">
<xsl:output method="text" version="1.0" encoding="UTF-8" indent="yes"/>

<xsl:param name="spineml_2_brahms_dir" select="'../../'"/>

<xsl:include href="SpineML_helpers.xsl"/>


<xsl:template match="/">
<xsl:for-each select="//SMLNL:PostSynapse">
<xsl:variable name="linked_file" select="document(@url)"/>
<xsl:variable name="process_name"><xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass"><xsl:value-of select="translate(@name,' -', 'oH')"/>
</xsl:for-each></xsl:variable>
<!-- Here we use the numbers to determine what we are outputting -->
<xsl:variable name="number1"><xsl:number count="/SMLNL:SpineML/SMLNL:Population" format="1"/></xsl:variable>
<xsl:variable name="number2"><xsl:number count="SMLNL:Projection" format="1"/></xsl:variable>
<xsl:variable name="number3"><xsl:number count="SMLNL:Synapse" format="1"/></xsl:variable>
<xsl:if test="$number1 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number1) and $number2 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number2) and $number3 = number(document(concat($spineml_2_brahms_dir,'/temp/counter.file'))/Nums/Number3)">

/*
   Autogenerated BRAHMS process from SpineML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: <xsl:value-of select="@name"/>
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/temp/<xsl:value-of select="$process_name"/>"
#define COMPONENT_CLASS_CPP dev_nineml_<xsl:value-of select="$process_name"/>_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=SpineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "rng.h"

#include "impulse.h"

/* helper function for doing the indexing... do we need this?
int getIndex(VDOUBLE position, VDOUBLE size) {

	int index = 0;
	int mult = 1;
	for (int i = 0; i &lt; size.size(); ++i) {
		index = index + pos[i] * mult;
		mult = mult * size[i];
	}

}*/

// structure allowing weights to be sent with spikes
struct INT32SINGLE {
	INT32 i;
	SINGLE s;
};

float dt;
float t;

class COMPONENT_CLASS_CPP;

<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncsPtr1"/>
</xsl:for-each>

////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:



// define regimes
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineRegime"/>
</xsl:for-each>


// Global variables
vector &lt; int &gt; <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime;
vector &lt; int &gt; <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext;


VDOUBLE size;
int numElements;

// Analog Ports
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogSendPort | SMLCL:AnalogReducePort" mode="defineAnalogPorts"/>
</xsl:for-each>

// Event Ports
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="defineEventPorts"/>
</xsl:for-each>

// Impulse Ports
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="defineImpulsePorts"/>
</xsl:for-each>

// State Variables
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:StateVariable" mode="defineStateVariable"/>
</xsl:for-each>

// Parameters
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:Parameter" mode="defineParameter"/>
</xsl:for-each>

<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncs"/>
</xsl:for-each>

// forward euler
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	return x + (*this.*func)(x,num)*dt;

}
/*
// Runge Kutta 4th order
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	float k1 = dt*(*this.*func)(x,num);
	float k2 = dt*(*this.*func)(x+0.5*k1,num);
	float k3 = dt*(*this.*func)(x+0.5*k2,num);
	float k4 = dt*(*this.*func)(x+k3,num);
	return x + (1.0/6.0)*(k1 + 2.0*k2 + 2.0*k3 + k4);

}*/

};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&amp;xmlNode);

			// obtain the parameters
			size = nodeState.getField("size").getArrayDOUBLE();
			numElements = 1;
			for (int i = 0; i &lt; size.size(); ++i) {
				numElements *= size[i];
			}		

			zigset(11);


			int numEl = numElements;

			// State Variables
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:StateVariable" mode="assignStateVariable"/>
</xsl:for-each>

			// Parameters
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
<xsl:apply-templates select="SMLCL:Parameter" mode="assignParameter"/>
</xsl:for-each>

			// Alias resize
<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
<xsl:apply-templates select="SMLCL:Alias" mode="resizeAlias"/>
</xsl:for-each>

<xsl:text>
                        </xsl:text><xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.resize(numEl,1);
                        <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext.resize(numEl,0);


			dt = 1000.0f * time->sampleRate.den / time->sampleRate.num;

<!---->
			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass/SMLCL:Dynamics">
				<xsl:apply-templates select="SMLCL:Regime" mode="defineTimeDerivFuncsPtr"/>
			</xsl:for-each>
<!---->

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort" mode="resizeReceive"/>
			</xsl:for-each>

		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
			Dims sizeDims;
			for (int i = 0; i &lt; size.size(); ++i) {
				sizeDims.push_back(size[i]);
			}
			//	on first call
			if (event->flags &amp; F_FIRST_CALL)
			{

<!---->
				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogSendPort" mode="createAnalogSendPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:ImpulseSendPort" mode="createImpulseSendPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:EventSendPort" mode="createEventSendPorts"/>
				</xsl:for-each>
<!---->

			}

			//	on last call
			if (event->flags &amp; F_LAST_CALL)
			{

				int numInputs;
				Symbol set;

				// create input ports
<!---->
				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogReceivePort" mode="createAnalogRecvPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:AnalogReducePort" mode="createAnalogReducePorts"/>
				</xsl:for-each>

				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:ImpulseReceivePort" mode="createImpulseRecvPorts"/>
				</xsl:for-each>

				<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
					<xsl:apply-templates select="SMLCL:EventReceivePort" mode="createEventRecvPorts"/>
				</xsl:for-each>

<!---->


			}

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{

			t = float(time->now)*dt;

			int num;
			int numEl = numElements;
			
                        for (int i = 0; i &lt; <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.size(); ++i) {
                                <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext[i] = <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime[i];

			}
			
			// service inputs
			
<!---->

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogSendPort | SMLCL:AnalogReducePort" mode="serviceAnalogPorts"/>
			</xsl:for-each>

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="serviceImpulsePorts"/>
			</xsl:for-each>

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="serviceEventPorts"/>
			</xsl:for-each>		

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doEventInputs"/>
			</xsl:for-each>
			
			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doImpulseInputs"/>
			</xsl:for-each>
			
			<!---->
			
			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doIter"/>
			</xsl:for-each>

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:Dynamics" mode="doTrans"/>
			</xsl:for-each>
<!---->
			
			// Apply regime changes
                        for (int i = 0; i &lt; <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime.size(); ++i) {
                                <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime[i] = <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regimeNext[i];
			}
			
                        //bout &lt;&lt; "A: " &lt;&lt; <xsl:value-of select="concat(translate($linked_file/SMLCL:SpineML/SMLCL:ComponentClass/@name,' -', '_H'), 'O__O')"/>regime[4] &lt;&lt; " " &lt;&lt; PSP[4] &lt;&lt; " " &lt;&lt; h[4] &lt;&lt; " " &lt;&lt; Isyn[4] &lt;&lt; D_INFO;
<!---->
			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:AnalogReceivePort | SMLCL:AnalogSendPort | SMLCL:AnalogReducePort" mode="outputAnalogPorts"/>
			</xsl:for-each>

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:EventReceivePort | SMLCL:EventSendPort" mode="outputEventPorts"/>
			</xsl:for-each>	

			<xsl:for-each select="$linked_file/SMLCL:SpineML/SMLCL:ComponentClass">
				<xsl:apply-templates select="SMLCL:ImpulseReceivePort | SMLCL:ImpulseSendPort" mode="outputImpulsePorts"/>
			</xsl:for-each>					

			
			//	ok
			return C_OK;
		}

	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


</xsl:if>


</xsl:for-each>


</xsl:template>

<xsl:include href="SpineML_Dynamics.xsl"/>
<xsl:include href="SpineML_Regime.xsl"/>
<xsl:include href="SpineML_StateVariable.xsl"/>
<xsl:include href="SpineML_Parameter.xsl"/>
<xsl:include href="SpineML_AnalogPort.xsl"/>
<xsl:include href="SpineML_EventPort.xsl"/>
<xsl:include href="SpineML_ImpulsePort.xsl"/>

</xsl:stylesheet>


