

/*
   Autogenerated BRAHMS process from 9ML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: 
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/tools/explicitList"
#define COMPONENT_CLASS_CPP dev_spineml_tools_explicitlist_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=NineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "impulse.h"

#include "rng.h"

class COMPONENT_CLASS_CPP;



////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:





// Analog Ports

numeric::Input in;

numeric::Output out;

spikes::Input ins;

spikes::Output outs;

spikes::Input ini;

spikes::Output outi;

bool spikesIn;
bool impulseIn;

int numElementsIn;
int numElementsOut;

vector <INT32> srcInds; 
vector <INT32> dstInds; 

bool portFound;

vector < vector <INT32> > spikeInds; 
};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&xmlNode);

			// obtain the parameters
			VDOUBLE size = nodeState.getField("sizeIn").getArrayDOUBLE();
			numElementsIn = 1;
			for (int i = 0; i < size.size(); ++i) {
				numElementsIn *= size[i];
			}		

			size = nodeState.getField("sizeOut").getArrayDOUBLE();
			numElementsOut = 1;
			for (int i = 0; i < size.size(); ++i) {
				numElementsOut *= size[i];
			}
			
			DOUBLE seedVal = nodeState.getField("seed").getDOUBLE();
			
			DOUBLE p = nodeState.getField("p").getDOUBLE();

			seed = seedVal;

			// generate connectivity
			for (UINT32 i = 0; i < numElementsIn; ++i) {
				for (UINT32 j = 0; j < numElementsOut; ++j) {
					if (p < uniformGCC()) {
						srcInds.push_back(i);
						dstInds.push_back(j);
					}
				}			
			}
		
			spikesIn = false;
			impulseIn = false;
			portFound = false;

			return C_OK;


		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
		
			//	on each call
			int numInputs = iif.getNumberOfPorts();
			
			if (numInputs == 1 && portFound == false) {
				portFound = true;
		
				if (in.tryAttach(hComponent, "in")) {
					out.setName("out");
					out.create(hComponent);
					out.setStructure(TYPE_DOUBLE | TYPE_REAL, Dims(numElementsOut).cdims());
				}
				if (ins.tryAttach(hComponent,"inSpike")) {
					spikesIn = true;
					outs.setName("out");
					outs.create(hComponent);
					outs.setCapacity(numElementsIn*numElementsOut);
					
					// create lookup for spikes
					spikeInds.resize(numElementsIn);
					for (int i = 0; i < srcInds.size(); ++i) {
						spikeInds[srcInds[i]].push_back(dstInds[i]);			
					}
					
				}
				if (ini.tryAttach(hComponent,"inImpulse")) {
					impulseIn = true;
					outi.setName("out");
					outi.create(hComponent);
					outi.setCapacity(numElementsIn*numElementsOut*3);
				
					// create lookup for spikes
					spikeInds.resize(numElementsIn);
					for (int i = 0; i < srcInds.size(); ++i) {
						spikeInds[srcInds[i]].push_back(dstInds[i]);			
					}
				
				}
			}

			//	on last call
			if (event->flags & F_LAST_CALL)
			{
			}

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{
			if (!spikesIn && !impulseIn) {
				DOUBLE * inData;
				inData = (DOUBLE*) in.getContent();
				
				DOUBLE * outData;
				outData = (DOUBLE *) out.getContent();
			
				// clear old data
				memset(outData, 0, 8*numElementsOut);
			
				for (UINT32 i = 0; i < srcInds.size(); ++i) {
					outData[dstInds[i]] += inData[srcInds[i]];
				}
			}
			if (spikesIn) 
			{
				INT32 * spikeData;
				UINT32 numSpikes;
				numSpikes = ins.getContent(spikeData);
			
				VINT32 outData;
				// for each input spike
				for (UINT32 i = 0; i < numSpikes; ++i) {
					// for each target of the source of that spike
					for (UINT32 j = 0; j < spikeInds[spikeData[i]].size(); ++j) {
						// add output spike to the list 
						outData.push_back(spikeInds[spikeData[i]][j]);
					}
				}
				
	
				outs.setContent(&(outData[0]), outData.size());
			}
			if (impulseIn) 
			{
				INT32 * data;
				UINT32 count;
				count = ini.getContent(data);
						
				DOUBLE totalImpulse = 0;
					
				VINT32 outData;	
				// for each impulse
				for (UINT32 i = 0; i < count; i+=3) {
				
					// extract impulses and sum
					INT32 index;
					DOUBLE value;
					getImpulse(data,i,index,value);
					
					// for each target of the source of that impulse
					for (UINT32 j = 0; j < spikeInds[index].size(); ++j) {
						// add output impulse to the list 
						addImpulse(outData, spikeInds[index][j], value);
					}					
				
				}
	
				outi.setContent(&(outData[0]), outData.size());
			}
						
			//	ok
			return C_OK;
		}

	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


