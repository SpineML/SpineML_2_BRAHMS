

/*
   Autogenerated BRAHMS process from 9ML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: 
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/tools/AnalogTimeVaryingInput"
#define COMPONENT_CLASS_CPP dev_spineml_tools_analogtimevaryinginput_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=SpineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

class COMPONENT_CLASS_CPP;

#include <sstream>

string stringify(int val) {
    stringstream ss (stringstream::in | stringstream::out);
    ss << float(val);
    string returnVal = ss.str().c_str();
    return returnVal;
}

////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:



struct timePoint {
	float time;
	float value;
};

// Analog Ports

numeric::Output out;

VDOUBLE values;

vector < vector < timePoint > > timePointsArray;

float dt;

};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
		
			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&xmlNode);
			
			// obtain the parameters
			if (nodeState.hasField("values")) {
				values = nodeState.getField("values").getArrayDOUBLE();
				Dims dims = nodeState.getField("values").getDims();
				
				vector < timePoint > newVTP;

				for (UINT32 i = 0; i < values.size(); i+=2) { 
					timePoint newTP;
					newTP.time = values[i];
					newTP.value = values[i+1];
					newVTP.push_back(newTP);
				}
				
				timePointsArray.push_back(newVTP);
				
			} else {
			
				int i = 0;
				string name = "values" + stringify(i);
				while (nodeState.hasField(name.c_str())) {
				
					values = nodeState.getField(name.c_str()).getArrayDOUBLE();
					
					vector < timePoint > newVTP;

					for (UINT32 j = 0; j < values.size()/2; ++j) { 
						timePoint newTP;
						newTP.time = values[j];
						newTP.value = values[j+values.size()/2];
						newVTP.push_back(newTP);
					}
					
					timePointsArray.push_back(newVTP);
					++i;
					name = "values" + stringify(i);
				}			
			
			}
			
			values.resize(timePointsArray.size(),0);

			dt = 1000.0f * time->sampleRate.den / time->sampleRate.num; // time step in ms

			return C_OK;


		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
		
			//	on first call
			if (event->flags & F_FIRST_CALL)
			{
			
				out.setName("out");
				out.create(hComponent);
				out.setStructure(TYPE_DOUBLE | TYPE_REAL, Dims(values.size()).cdims());

			}

			//	on last call
			if (event->flags & F_LAST_CALL)
			{
			}

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{
		
			float t = float(time->now)*dt;
			
			for (UINT32 i = 0; i < timePointsArray.size(); ++i) {
			
				for (UINT32 j = 0; j < timePointsArray[i].size(); ++j) {
					if (timePointsArray[i][j].time <= t) {
						timePointsArray[i][j].time = INFINITY;
						values[i] = timePointsArray[i][j].value;
					}
				}
			
			}
	
			out.setContent(&(values[0]));
									
			//	ok
			return C_OK;
		}

	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


