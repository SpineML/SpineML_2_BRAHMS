

/*
   Autogenerated BRAHMS process from 9ML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: 
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/tools/allToAll"
#define COMPONENT_CLASS_CPP dev_spineml_tools_alltoall_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=NineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "impulse.h"

class COMPONENT_CLASS_CPP;



////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:





// Analog Ports

numeric::Input in;

numeric::Output out;

spikes::Input ins;

spikes::Output outs;

spikes::Input ini;

spikes::Output outi;

bool spikesIn;
bool impulseIn;
bool portFound;

int numElementsIn;
int numElementsOut;

};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
		
			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&xmlNode);
			
			// obtain the parameters
			VDOUBLE size = nodeState.getField("sizeIn").getArrayDOUBLE();
			numElementsIn = 1;
			for (unsigned int i = 0; i < size.size(); ++i) {
				numElementsIn *= size[i];
			}		

			size = nodeState.getField("sizeOut").getArrayDOUBLE();
			numElementsOut = 1;
			for (unsigned int i = 0; i < size.size(); ++i) {
				numElementsOut *= size[i];
			}
			
			spikesIn = false;
			impulseIn = false;
			portFound = false;

			return C_OK;


		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
			//	on each call
			int numInputs = iif.getNumberOfPorts();
			
			if (numInputs == 1 && portFound == false) {
				portFound = true;
		
				if (in.tryAttach(hComponent, "in")) {
					out.setName("out");
					out.create(hComponent);
					out.setStructure(TYPE_DOUBLE | TYPE_REAL, Dims(numElementsOut).cdims());
				}
				if (ins.tryAttach(hComponent,"inSpike")) {
					spikesIn = true;
					outs.setName("out");
					outs.create(hComponent);
					outs.setCapacity(numElementsIn*numElementsOut);
	
				}
				if (ini.tryAttach(hComponent,"inImpulse")) {
					impulseIn = true;
					outi.setName("out");
					outi.create(hComponent);
					outi.setCapacity(numElementsIn*numElementsOut*3);
				}
				
			}

			//	on last call
			if (event->flags & F_LAST_CALL)
			{
			}

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{
			if (!spikesIn && !impulseIn) {
				DOUBLE * inData;
				inData = (DOUBLE*) in.getContent();
			
				DOUBLE sum = 0;
				for (UINT32 i = 0; i < (UINT32)numElementsIn; ++i) {
					sum += inData[i];
				}
			
				VDOUBLE outData;
				outData.resize(numElementsOut, sum);
			
				out.setContent(&(outData[0]));
			}
			if (spikesIn) 
			{
				INT32 * spikeData;
				UINT32 numSpikes;
				numSpikes = ins.getContent(spikeData);
				
				
			
				VINT32 outData;
				for (UINT32 i = 0; i < (UINT32)numElementsOut; ++i) {
					for (UINT32 j = 0; j < numSpikes; ++j) {
						outData.push_back(i);
					}
				}
	
				outs.setContent(&(outData[0]), outData.size());
			}
			if (impulseIn) 
			{
				INT32 * data;
				UINT32 count;
				count = ini.getContent(data);
						
				DOUBLE totalImpulse = 0;
						
				for (UINT32 i = 0; i < count; i+=3) {
				
					// extract impulses and sum
					INT32 index;
					DOUBLE value;
					getImpulse(data,i,index,value);
					totalImpulse += value;
				
				}
			
				VINT32 outData;
				for (UINT32 i = 0; i < (UINT32)numElementsOut; ++i) {
					addImpulse(outData, i, totalImpulse);
				}
	
				outi.setContent(&(outData[0]), outData.size());
			}
						
			//	ok
			return C_OK;
		}

	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


