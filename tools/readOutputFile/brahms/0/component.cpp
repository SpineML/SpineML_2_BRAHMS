/*
 * This component reads an output file generated by a previous run of
 * a SpineML_2_BRAHMS model and can then be used to provide that as
 * input to another brahms model.
 *
 * This is being developed in order to run the University of
 * Patras/NoTremor biomechanical model as a standalone brahms model,
 * in advance of integrating it fully with a SpineML_2_BRAHMS brain
 * model.
 *
 * Engine Author: Seb James 2014
 * Node name: readOutputFile
 */

#define COMPONENT_CLASS_STRING "dev/SpineML/tools/readOutputFile"
#define COMPONENT_CLASS_CPP dev_spineml_tools_readoutputfile_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=Seb James\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

// include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

// alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "impulse.h"

/*
 * In a brahms component, you drive a component class from Process,
 * and add the private data attributes you will need, along with an
 * implementation of the event method.
 */
class COMPONENT_CLASS_CPP : public Process
{
public:
    // Empty constructor; this is not generally used.
    COMPONENT_CLASS_CPP() {}
    ~COMPONENT_CLASS_CPP() {}

    // The framework event method.
    Symbol event(Event* event);

private:
    // Analog ports
    numeric::Output out;
    // How many input elements do we have for each timestep?
    int datapointsPerTimestep;
    // The file we'll read from.
    FILE* binfile;
    // A temporary int for holding function return values
    int tmprtn;
};

/*
 * Event implementation. This is where all the action happens in a
 * brahms component.
 */
Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
    switch (event->type) {
        bout << "switch event->type" << D_INFO;
    case EVENT_STATE_SET:
    {
        bout << "EVENT_STATE_SET..." << D_INFO;
        // During this event, we read the component's DataML to
        // determine its runtime settings.

        EventStateSet* data = (EventStateSet*) event->data;
        XMLNode xmlNode(data->state);
        DataMLNode nodeState(&xmlNode);

        // In the logrep.xml file for the binary file we have these elements:
        // LogFileType (binary)
        // LogEndTime (e.g. 300.000000)
        // LogAll with parameters: size ("1") headings ("a") type ("double") dims ("")
        // TimeStep with parameter dt ("1.000000")
        //
        // Ideally, this component will read those parameters from the
        // file. Use RapidXML or perhaps TinyXML2 for this. Brahms has
        // its own library, but do we really want to use that?

        // obtain the parameters
        this->datapointsPerTimestep = nodeState.getField ("datapointsPerTimestep").getINT32();

        string binpath = nodeState.getField ("binpath").getSTRING();

        // Open the file.
        this->binfile = (FILE*)0;
        if (nodeState.hasField("_bin_file_name")) {

            string fileName = nodeState.getField ("_bin_file_name").getSTRING();
            fileName = binpath + fileName;
            bout << "Opening file " << fileName << D_INFO;
            this->binfile = fopen (fileName.c_str(), "rb");
            if (!this->binfile) {
                // That failed; try the default location for
                // spineml-2-brahms on a Unix system:
                fileName = "~/spineml-2-brahms/model/" + fileName;
                this->binfile = fopen (fileName.c_str(), "rb");
                if (!this->binfile) {
                    berr << "Could not open binary data file";
                }
            }

        } else {
            berr << "No _bin_file_name parameter was specified; can't read from file!";
        }

        return C_OK;
    }

    case EVENT_INIT_CONNECT:
    {
        // In the EVENT_INIT_CONNECT event, we connect the component's
        // ports. This event is called several times (for each port?).

        // This component only has output ports.
        this->out.setName ("out");
        this->out.create (hComponent);
        this->out.setStructure (TYPE_DOUBLE | TYPE_REAL, Dims(this->datapointsPerTimestep).cdims());

        // on last call
        if (event->flags & F_LAST_CALL) { /* Nothing to do in this component */ }

        return C_OK;
    }

    case EVENT_RUN_SERVICE:
    {
        DOUBLE* outData = (DOUBLE*) this->out.getContent();
        this->tmprtn = fread (outData, sizeof(DOUBLE), this->datapointsPerTimestep, this->binfile);
        if (this->tmprtn != this->datapointsPerTimestep) {
            bout << "tmprtn != datapointsPerTimestep..." << D_WARN;
            if (feof(this->binfile)) {
                bout << "Reached end of input file." << D_INFO;
            } else if (ferror (this->binfile)) {
                berr << "Error reading input file.";
            }
        } else {
            bout << "Read number: " << *outData << D_INFO;
        }
        return C_OK;
    }

    case EVENT_RUN_STOP:
    {
        if (this->binfile != (FILE*)0) {
            bout << "Close file..." << D_INFO;
            this->tmprtn = fclose (this->binfile);
            if (this->tmprtn) {
                berr << "Error closing file.";
            }
        }
        // ok, STOP event serviced.
        return C_OK;
    }

    } // end switch(event->type)

    // if we service the event, we return C_OK
    // if we don't, we should return S_NULL to indicate that we didn't
    return S_NULL;
}

// include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"
